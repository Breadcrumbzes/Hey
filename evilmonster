local monster = game:GetObjects("rbxassetid://8977159770")[1]
monster.Parent = workspace
monster:PivotTo(game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0,0,-10))
local function gonerai(CHARACTER)
	local IT = Instance.new
	local CF = CFrame.new
	local VT = Vector3.new
	local RAD = math.rad
	local C3 = Color3.new
	local UD2 = UDim2.new
	local BRICKC = BrickColor.new
	local ANGLES = CFrame.Angles
	local EULER = CFrame.fromEulerAnglesXYZ
	local COS = math.cos
	local ACOS = math.acos
	local SIN = math.sin
	local ASIN = math.asin
	local ABS = math.abs
	local MRANDOM = math.random
	local FLOOR = math.floor

	local scriptRef = CHARACTER:FindFirstChildOfClass("Script")

	-- Local character references
	local GYRO = nil
	local HUMANOID = CHARACTER:FindFirstChild("Polygoner")
	local TORSO = CHARACTER:FindFirstChild("Torso")
	local ROOT = CHARACTER:FindFirstChild("HumanoidRootPart")
	local RIGHTARM = CHARACTER:FindFirstChild("Right Arm")
	local LEFTARM = CHARACTER:FindFirstChild("Left Arm")
	local RIGHTLEG = CHARACTER:FindFirstChild("Right Leg")
	local LEFTLEG = CHARACTER:FindFirstChild("Left Leg")
	local AXE = CHARACTER:FindFirstChild("Axe")

	local RootJoint = ROOT and ROOT:FindFirstChild("Root")
	local Neck = TORSO and TORSO:FindFirstChild("Head")
	local RightShoulder = TORSO and TORSO:FindFirstChild("RArm")
	local LeftShoulder = TORSO and TORSO:FindFirstChild("LArm")
	local RightHip = TORSO and TORSO:FindFirstChild("RLeg")
	local LeftHip = TORSO and TORSO:FindFirstChild("LLeg")
	local Grab = RIGHTARM and RIGHTARM:FindFirstChild("Grasp")

	-- Body table of parts/joints for restoration/cloning
	local BODY = {}
	for _, CHILD in pairs(CHARACTER:GetDescendants()) do
		if CHILD:IsA("BasePart") or CHILD:IsA("JointInstance") then
			table.insert(BODY, {CHILD, CHILD.Parent})
		end
	end

	local ATTACKING = false
	local MUSIC = scriptRef:FindFirstChild("PolyTheme")
	if MUSIC then MUSIC:Play() end

	local HITPLAYERSOUNDS = {
		"263032172", "263032182", "263032200", "263032221", "263032252", "263033191"
	}

	if scriptRef:FindFirstChild("Color") then
		scriptRef.Color.Parent = game.Lighting
	end

	-- Clone for death fallback
	local CLONE = CHARACTER:Clone()
	CLONE.Parent = nil
	CHARACTER.Archivable = false

	local Debris = game:GetService("Debris")
	local Effects = IT("Folder")
	Effects.Parent = CHARACTER

	-- Artificial Heartbeat (per-instance)
	local ArtificialHB = IT("BindableEvent")
	ArtificialHB.Name = "ArtificialHB"
	ArtificialHB.Parent = scriptRef

	-- Heartbeat timing
	local frame = 1/60
	local tf = 0
	local allowframeloss = false
	local tossremainder = false
	local lastframe = tick()

	ArtificialHB:Fire()

	game:GetService("RunService").Heartbeat:Connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				ArtificialHB:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)

	-- Utility helpers (kept names/logic from original)
	local function PositiveAngle(NUMBER)
		if NUMBER >= 0 then
			NUMBER = 0
		end
		return NUMBER
	end

	local function NegativeAngle(NUMBER)
		if NUMBER <= 0 then
			NUMBER = 0
		end
		return NUMBER
	end

	local function Swait(NUMBER)
		if NUMBER == 0 or NUMBER == nil then
			ArtificialHB.Event:wait()
		else
			for i = 1, NUMBER do
				ArtificialHB.Event:wait()
			end
		end
	end

	-- Creation helpers
	local function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
		local NEWMESH = IT(MESH)
		if MESH == "SpecialMesh" then
			NEWMESH.MeshType = MESHTYPE
			if MESHID ~= "nil" and MESHID ~= "" then
				NEWMESH.MeshId = "http://www.roblox.com/asset/?id=" .. MESHID
			end
			if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
				NEWMESH.TextureId = "http://www.roblox.com/asset/?id=" .. TEXTUREID
			end
		end
		NEWMESH.Offset = OFFSET or VT(0, 0, 0)
		NEWMESH.Scale = SCALE
		NEWMESH.Parent = PARENT
		return NEWMESH
	end

	local function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
		local NEWPART = IT("Part")
		NEWPART.formFactor = FORMFACTOR
		NEWPART.Reflectance = REFLECTANCE
		NEWPART.Transparency = TRANSPARENCY
		NEWPART.CanCollide = false
		NEWPART.Locked = true
		NEWPART.Anchored = true
		if ANCHOR == false then
			NEWPART.Anchored = false
		end
		NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
		NEWPART.Name = NAME
		NEWPART.Size = SIZE
		if TORSO then NEWPART.Position = TORSO.Position end
		NEWPART.Material = MATERIAL
		NEWPART:BreakJoints()
		NEWPART.Parent = PARENT
		return NEWPART
	end

	local function weldBetween(a, b)
		local weldd = IT("ManualWeld")
		weldd.Part0 = a
		weldd.Part1 = b
		weldd.C0 = CF()
		weldd.C1 = b.CFrame:inverse() * a.CFrame
		weldd.Parent = a
		return weldd
	end

	local S = IT("Sound")
	local function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
		local NEWSOUND = nil
		coroutine.resume(coroutine.create(function()
			NEWSOUND = S:Clone()
			NEWSOUND.Parent = PARENT
			NEWSOUND.Volume = VOLUME
			NEWSOUND.Pitch = PITCH
			NEWSOUND.SoundId = "http://www.roblox.com/asset/?id=" .. ID
			NEWSOUND:Play()
			if DOESLOOP == true then
				NEWSOUND.Looped = true
			else
				repeat wait(1) until NEWSOUND.Playing == false
				NEWSOUND:Destroy()
			end
		end))
		return NEWSOUND
	end

	local function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
		return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
	end

	-- CLERP and quaternion helpers (copied directly)
	local function QuaternionFromCFrame(cf)
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
		local trace = m00 + m11 + m22
		if trace > 0 then
			local s = math.sqrt(1 + trace)
			local recip = 0.5 / s
			return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
		else
			local i = 0
			if m11 > m00 then
				i = 1
			end
			if m22 > (i == 0 and m00 or m11) then
				i = 2
			end
			if i == 0 then
				local s = math.sqrt(m00 - m11 - m22 + 1)
				local recip = 0.5 / s
				return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
			elseif i == 1 then
				local s = math.sqrt(m11 - m22 - m00 + 1)
				local recip = 0.5 / s
				return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
			elseif i == 2 then
				local s = math.sqrt(m22 - m00 - m11 + 1)
				local recip = 0.5 / s
				return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
			end
		end
	end

	local function QuaternionToCFrame(px, py, pz, x, y, z, w)
		local xs, ys, zs = x + x, y + y, z + z
		local wx, wy, wz = w * xs, w * ys, w * zs
		local xx = x * xs
		local xy = x * ys
		local xz = x * zs
		local yy = y * ys
		local yz = y * zs
		local zz = z * zs
		return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
	end

	local function QuaternionSlerp(a, b, t)
		local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
		local startInterp, finishInterp
		if cosTheta >= 0.0001 then
			if (1 - cosTheta) > 0.0001 then
				local theta = ACOS(cosTheta)
				local invSinTheta = 1 / SIN(theta)
				startInterp = SIN((1 - t) * theta) * invSinTheta
				finishInterp = SIN(t * theta) * invSinTheta
			else
				startInterp = 1 - t
				finishInterp = t
			end
		else
			if (1 + cosTheta) > 0.0001 then
				local theta = ACOS(-cosTheta)
				local invSinTheta = 1 / SIN(theta)
				startInterp = SIN((t - 1) * theta) * invSinTheta
				finishInterp = SIN(t * theta) * invSinTheta
			else
				startInterp = t - 1
				finishInterp = t
			end
		end
		return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
	end

	local function Clerp(a, b, t)
		local qa = {QuaternionFromCFrame(a)}
		local qb = {QuaternionFromCFrame(b)}
		local ax, ay, az = a.x, a.y, a.z
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1 - t
		return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
	end

	local function ClerpBody(TABLE, PRIORITY)
		if PRIORITY == "Attack" or ATTACKING == false then
			if RootJoint then RootJoint.C1 = Clerp(RootJoint.C1, TABLE[1], 0.35) end
			if Neck then Neck.C1 = Clerp(Neck.C1, TABLE[2], 0.35) end
			if RightShoulder then RightShoulder.C1 = Clerp(RightShoulder.C1, TABLE[3], 0.35) end
			if LeftShoulder then LeftShoulder.C1 = Clerp(LeftShoulder.C1, TABLE[4], 0.35) end
			if RightHip then RightHip.C1 = Clerp(RightHip.C1, TABLE[5], 0.35) end
			if LeftHip then LeftHip.C1 = Clerp(LeftHip.C1, TABLE[6], 0.35) end
			if Grab then Grab.C0 = Clerp(Grab.C0, TABLE[7], 0.35) end
		end
	end

	-- SpawnPuddle (keeps behavior)
	local function SpawnPuddle(POSITION, IGNR, GOO)
		local HIT, POS, NOR = Raycast(POSITION, CF(POSITION, POSITION - VT(0, 1, 0)).lookVector, 12, IGNR)
		if HIT then
			coroutine.resume(coroutine.create(function()
				local GOREPART = CreatePart(3, Effects, "Slate", 0, 1, "Pearl", "Gore", VT(3, 0, 3), true)
				local SURFACE = scriptRef.PuddleSurface:Clone()
				SURFACE.Parent = GOREPART
				if GOO == true then
					SURFACE.Image.ImageColor3 = C3(0, 0, 0)
				end
				GOREPART.CFrame = CFrame.new(POS, POS + NOR) * CFrame.Angles(math.rad(-90), math.rad(math.random(0, 360)), 0)
				for i = 1, math.random(25, 65) do
					wait()
					GOREPART.Size = GOREPART.Size + Vector3.new(0.1, 0, 0.1)
				end
				wait(math.random(10, 25) / 10)
				for i = 1, 25 do
					wait()
					SURFACE.Image.ImageTransparency = SURFACE.Image.ImageTransparency + 1 / 25
				end
				GOREPART:Destroy()
			end))
		end
	end

	-- AI attack execution
	local function Execute(TARGET)
		for i = 1, 5 do
			Swait()
			ClerpBody({
				CF(0, 0.2, 0) * ANGLES(0, RAD(15), 0),
				CF(0, -1.5, 0) * ANGLES(RAD(-15), -RAD(15), 0),
				CF(-1.5, 0.75, 0) * ANGLES(0, RAD(-15), RAD(-90)) * CF(-1, 0, 0),
				CF(1.5, 0.5, 0) * ANGLES(RAD(-115), RAD(-15), 0) * CF(0, -0.5, 0),
				CF(-0.55, 2, 0.35) * ANGLES(0, RAD(-5), 0) * ANGLES(0, 0, 0),
				CF(0.65, 2, 0.35) * ANGLES(0, RAD(-20), 0) * ANGLES(0, 0, 0),
				CF(0, 0, 0)
			}, nil)
		end
		ATTACKING = true
		TARGET:BreakJoints()
		local PRIMARY = TARGET:FindFirstChild("UpperTorso") or TARGET:FindFirstChild("Torso")
		if PRIMARY then
			local function Spill(PART)
				if PART then
					coroutine.resume(coroutine.create(function()
						repeat
							Swait(MRANDOM(5, 12))
							SpawnPuddle(PART.CFrame * CF(0, PART.Size.Y / 2, 0).p, Effects, false)
						until PART:FindFirstAncestor("Workspace") == nil
					end))
				end
			end
			CreateSound(566593606, PRIMARY, 5, 1, false)
			CreateSound(3737268126, PRIMARY, 5, 1, false)
			TARGET.Parent = Effects
			if TARGET:FindFirstChild("UpperTorso") then
				local RAGDOLLER = scriptRef.R15Ragdoll:Clone()
				RAGDOLLER.Parent = TARGET
				RAGDOLLER.Disabled = false
				local FOUNTAIN = IT("Attachment", TARGET:FindFirstChild("UpperTorso"))
				FOUNTAIN.Name = "LostNeck"
				FOUNTAIN.Position = VT(0, TARGET:FindFirstChild("UpperTorso").Size.Y / 2, 0)
				local BLOOD = scriptRef.Fountain:Clone()
				BLOOD.Parent = FOUNTAIN
				BLOOD.Enabled = true
				Spill(TARGET.UpperTorso)
			else
				local RAGDOLLER = scriptRef.R6Ragdoll:Clone()
				RAGDOLLER.Parent = TARGET
				RAGDOLLER.Disabled = false
				local FOUNTAIN = IT("Attachment", TARGET:FindFirstChild("Torso"))
				FOUNTAIN.Name = "LostNeck"
				FOUNTAIN.Position = VT(0, TARGET:FindFirstChild("Torso").Size.Y / 2, 0)
				local BLOOD = scriptRef.Fountain:Clone()
				BLOOD.Parent = FOUNTAIN
				BLOOD.Enabled = true
				Spill(TARGET.Torso)
			end
			local BASE = TARGET:FindFirstChild("HumanoidRootPart")
			if BASE then
				BASE:Destroy()
			end
			Debris:AddItem(TARGET, 5)
			local OFFICIALLYDEAD = IT("Folder", TARGET)
			OFFICIALLYDEAD.Name = "Polygoner_Slain"
			for i = 1, 25 do
				Swait()
				ClerpBody({
					CF(0, 0, 0) * ANGLES(0, RAD(-45), 0),
					CF(0, -1.5, 0) * ANGLES(RAD(15), RAD(25), 0),
					CF(-2, 0.65, -1) * ANGLES(0, 0, RAD(90)) * ANGLES(RAD(-15), 0, RAD(15)) * CF(-1, 0, 0.5) * ANGLES(RAD(180), 0, 0) * CF(-0.5, 1, 1.5) * ANGLES(0, 0, 0),
					CF(1.5, 0, 0),
					CF(-0.5, 2, 0) * ANGLES(0, RAD(5), 0),
					CF(0.5, 2, 0.5) * ANGLES(RAD(10), RAD(-15), 0),
					CF(0, 0, 0) * ANGLES(RAD(75), 0, 0) * CF(0, 0.5, 0)
				}, "Attack")
			end
			coroutine.resume(coroutine.create(function()
				repeat wait() until ROOT:FindFirstChild("Kill") and ROOT.Kill.Playing == false
				if ROOT:FindFirstChild("Taunt") then ROOT.Taunt:Play() end
			end))
		end
		ATTACKING = false
	end

	-- Chatter
	local function Chatter()
		local CHAT = true
		local CHATTERS = {}
		for _, CHILD in pairs(ROOT:GetChildren()) do
			if CHILD:IsA("Sound") then
				if CHILD.Playing == true then
					CHAT = false
					break
				else
					if CHILD.Name == "Chatter" then
						table.insert(CHATTERS, CHILD)
					end
				end
			end
		end
		if CHAT == true and #CHATTERS > 0 then
			CHATTERS[MRANDOM(1, #CHATTERS)]:Play()
		end
	end

	local function TestForTarget(PRT, target)
		local to = true
		if PRT then
			if PRT:FindFirstAncestorOfClass("Model") == target.Parent then
				to = false
			end
		end
		return to
	end

	-- BEGIN AI main loop and behavior
	local function BEGINAI()
		if game.Lighting then
			game.Lighting.Brightness = 2
			game.Lighting.ClockTime = 14
		end

		local ANIM = "Idle"
		if HUMANOID then
			HUMANOID.Running:Connect(function(speed)
				if speed > 0 then
					if HUMANOID.WalkSpeed < 16 then
						ANIM = "Walk"
					else
						ANIM = "Run"
					end
				else
					ANIM = "Idle"
				end
			end)
		end

		-- Surrounding player effects loop
		task.spawn(function()
			local SINE = 0
			game:GetService("RunService").Heartbeat:Connect(function()
				for _, PLAYER in pairs(game.Players:GetPlayers()) do
					if PLAYER.Character then
						local AVATAR = PLAYER.Character
						local ROOT2 = AVATAR.PrimaryPart
						local HUM = AVATAR:FindFirstChildOfClass("Humanoid")
						if ROOT2 and HUM and ROOT then
							local DIST = (ROOT2.Position - ROOT.Position).Magnitude
							if DIST <= 100 then
								local STATIC = nil
								local POWER = math.ceil((100 - DIST))
								HUM.CameraOffset = VT(MRANDOM(-POWER, POWER), MRANDOM(-POWER, POWER), MRANDOM(-POWER, POWER)) / 100
								if PLAYER.PlayerGui:FindFirstChild("GonerStatic") then
									STATIC = PLAYER.PlayerGui:FindFirstChild("GonerStatic")
									STATIC.Static.ImageTransparency = (100 - (POWER / 4)) / 100
									STATIC.Script.Static.Volume = POWER / 10
								else
									STATIC = scriptRef.GonerStatic:Clone()
									STATIC.Parent = PLAYER.PlayerGui
									STATIC.Script.Disabled = false
									STATIC.Static.ImageTransparency = (100 - (POWER / 4)) / 100
									local SOUND = scriptRef.Static:Clone()
									SOUND.Parent = STATIC.Script
									SOUND.Volume = POWER / 10
									local DIE = scriptRef.Taunt:Clone()
									DIE.Parent = STATIC.Script
								end
							else
								if PLAYER.PlayerGui:FindFirstChild("GonerStatic") then
									PLAYER.PlayerGui:FindFirstChild("GonerStatic"):Destroy()
								end
								HUM.CameraOffset = VT(0, 0, 0)
							end
						end
					end
				end
				-- default idle posture table
				local DEFAULTS = {
					CF(0, 0, 0),
					CF(0, -1.5, 0),
					CF(-1.5, 0, 0),
					CF(1.5, 0, 0),
					CF(-0.5, 2, 0),
					CF(0.5, 2, 0),
					CF(0, 0, 0)
				}
				SINE = SINE + 1
				local FLOORTRACE = Raycast(ROOT.Position, (CF(ROOT.Position, ROOT.Position + VT(0, -1, 0))).lookVector, 5, CHARACTER)
				if FLOORTRACE then
					if MRANDOM(1, 5) == 1 then
						SpawnPuddle(ROOT.Position, CHARACTER, true)
					end
					if ANIM == "Idle" then
						if AXE and AXE:FindFirstChild("Drag") then AXE.Drag:Stop() end
						ClerpBody({
							CF(0, 0.1 * COS(SINE / 12), 0) * ANGLES(0, RAD(15), 0),
							CF(0, -1.5, 0) * ANGLES(RAD(3 * SIN(SINE / 12)), RAD(-15), 0),
							CF(-1.5, 0.5 - 0.1 * COS(SINE / 12), 0) * ANGLES(RAD(-15), RAD(-15), 0) * CF(0, -0.5, 0),
							CF(1.5, 0, 0),
							CF(-0.5, 2 - 0.1 * COS(SINE / 12), 0) * ANGLES(0, RAD(5), 0),
							CF(0.5, 2 - 0.1 * COS(SINE / 12), 0.5) * ANGLES(RAD(10), RAD(-15), 0),
							CF(0, 0, 0)
						}, nil)
					elseif ANIM == "Walk" then
						if AXE and AXE:FindFirstChild("Drag") then AXE.Drag.Playing = true end
						ClerpBody({
							CF(0, 0.1 * COS(SINE / 5), 0) * ANGLES(RAD(25), RAD(3 * SIN(SINE / 5)), 0),
							CF(0, -1.5, 0) * ANGLES(RAD(-15), RAD(3 * SIN(SINE / 10)), 0),
							CF(0, 0.5, 0) * ANGLES(RAD(-40), RAD(35 - 3 * SIN(SINE / 5)), 0) * CF(-1.5, -0.5, 0),
							CF(1.5, 0.5, 0) * ANGLES(RAD(-15 - (35 * COS(SINE / 10))), RAD(-15), 0) * CF(0, 0, 0),
							CF(-0.5, 2 + 0.35 * SIN(SINE / 10), 0.3 - 0.3 * SIN(SINE / 10)) * ANGLES(RAD(-15 - (35 * COS(SINE / 10))), 0, 0),
							CF(0.5, 2 - 0.35 * SIN(SINE / 10), 0.3 + 0.3 * SIN(SINE / 10)) * ANGLES(RAD(-15 + (35 * COS(SINE / 10))), 0, 0),
							CF(0, 0, 0)
						}, nil)
					elseif ANIM == "Run" then
						if AXE and AXE:FindFirstChild("Drag") then AXE.Drag.Playing = true end
						ClerpBody({
							CF(0, 0.1 * COS(SINE / 5), 0) * ANGLES(RAD(25), RAD(3 * SIN(SINE / 5)), 0),
							CF(0, -1.5, 0) * ANGLES(RAD(-15), RAD(3 * SIN(SINE / 10)), 0),
							CF(0, 0.5, 0) * ANGLES(RAD(-40), RAD(35 - 3 * SIN(SINE / 5)), 0) * CF(-1.5, -0.5, 0),
							CF(1.5, 0.5, 0) * ANGLES(RAD(-15 - (35 * COS(SINE / 10))), RAD(-15), 0) * CF(0, 0, 0),
							CF(-0.5, 2 + 0.35 * SIN(SINE / 10), 0.3 - 0.3 * SIN(SINE / 10)) * ANGLES(RAD(-15 - (35 * COS(SINE / 10))), 0, 0),
							CF(0.5, 2 - 0.35 * SIN(SINE / 10), 0.3 + 0.3 * SIN(SINE / 10)) * ANGLES(RAD(-15 + (35 * COS(SINE / 10))), 0, 0),
							CF(0, 0, 0)
						}, nil)
					end
				else
					if AXE and AXE:FindFirstChild("Drag") then AXE.Drag:Stop() end
					ClerpBody({
						CF(0, 0, 0) * ANGLES(RAD(-10), RAD(5), 0),
						CF(0, -1.5, 0) * ANGLES(RAD(15), RAD(-5), 0),
						CF(-1.5, 0, 0.2) * ANGLES(RAD(-15), 0, 0),
						CF(1.5, -0.5, 0) * ANGLES(RAD(-35), 0, 0) * CF(0, 0.5, 0),
						CF(-0.5, 2, 0.2) * ANGLES(RAD(10), RAD(-5), 0),
						CF(0.5, 1.5, 1) * ANGLES(RAD(10), RAD(-15), 0),
						CF(0, 0, 0)
					}, nil)
				end
			end)
		end)

if HUMANOID then
			HUMANOID.Died:Connect(function()
				CLONE.Parent = workspace
				if CLONE.PrimaryPart and ROOT then
					CLONE:SetPrimaryPartCFrame(ROOT.CFrame)
				end
				if CLONE.PrimaryPart and CLONE.PrimaryPart:FindFirstChild("Respawn") then
					CLONE.PrimaryPart.Respawn:Play()
				end
				CHARACTER:Destroy()
			end)
		end

		-- Targeting / pathing coroutine:
		coroutine.resume(coroutine.create(function()
			local h = HUMANOID
			local pathService = game:GetService("PathfindingService")
			local Target = nil

			local function closestTargetAndPath()
				local humanoids = {}
				for _, v in pairs(workspace:GetChildren()) do
					if v:FindFirstChild("HumanoidRootPart") and v:FindFirstChildOfClass("Humanoid") and v ~= CHARACTER and v:FindFirstChild("Slain") == nil then
						if v:FindFirstChildOfClass("Humanoid").Health > 0 then
							table.insert(humanoids, v:FindFirstChildOfClass("Humanoid"))
						end
					end
				end
				local closest, path, dist
				for _, humanoid in pairs(humanoids) do
					if humanoid.Torso then
						local ok, myPath = pcall(function()
							return pathService:ComputeRawPathAsync(h.Torso.Position, humanoid.Torso.Position, 50)
						end)
						if ok and myPath and myPath.Status ~= Enum.PathStatus.FailFinishNotEmpty then
							-- compute distance along path
							local myDist = 0
							local previous = h.Torso.Position
							for _, point in pairs(myPath:GetPointCoordinates()) do
								myDist = myDist + (point - previous).magnitude
								previous = point
							end
							if not dist or myDist < dist then
								closest = humanoid
								path = myPath
								dist = myDist
							end
						end
					end
				end
				return closest, path
			end

			local function goToPos(loc, target)
				if not h then return end
				h:MoveTo(loc)
				local distance = (loc - h.Torso.Position).magnitude
				local start = tick()
				while distance > 4 do
					if target then
						if target.Torso then
							local RAYTEST = Raycast(ROOT.Position, CF(ROOT.Position, VT(target.Torso.Position.X, ROOT.Position.Y, target.Torso.Position.Z)).lookVector, 500, CHARACTER)
							if tick() - start > distance / h.WalkSpeed then
								break
							end
							distance = (loc - ROOT.Position).magnitude
							Swait()
						else
							break
						end
					else
						break
					end
				end
			end

			while true do
				Swait()
				if GYRO == nil then
					local target, path = closestTargetAndPath()
					local didBreak = false
					local targetStart
					if target and h.Torso and target.Torso then
						Target = target
						targetStart = target.Torso.Position
						local previous = h.Torso.Position
						local points = path and path:GetWaypoints() or {}
						local s = #points > 1 and 2 or 1
						for i = s, #points do
							if GYRO == nil then
								local point = points[i].Position
								if didBreak then break end
								if target and target.Torso and target.Health > 0 then
									local RAYTEST = Raycast(ROOT.Position, CF(ROOT.Position, VT(target.Torso.Position.X, ROOT.Position.Y, target.Torso.Position.Z)).lookVector, 500, CHARACTER)
									if (ROOT.Position - point).Magnitude > 1 and TestForTarget(RAYTEST, target) == true then
										goToPos(previous:lerp(point, 0.5), target)
										previous = point
									end
								else
									didBreak = true
									break
								end
							end
						end
					else
						Target = nil
					end
					if not didBreak and targetStart then
						goToPos(targetStart)
					end
				end
			end
		end))

		-- Main loop: find nearest target and behavior
		while true do
			local TARGETVARIANTS = {}
			local TARGET = nil
			for _, CHILD in pairs(workspace:GetChildren()) do
				if CHILD ~= CHARACTER and CHILD:FindFirstChild("Polygoner_Slain") == nil then
					local HUMAN = CHILD:FindFirstChildOfClass("Humanoid")
					if HUMAN then
						if HUMAN.Health > 0 then
							if HUMAN.Torso then
								local DISTANCE = (HUMAN.Torso.Position - ROOT.Position).Magnitude
								table.insert(TARGETVARIANTS, {CHILD, DISTANCE})
							end
						end
					end
				end
			end
			local DIST = math.huge
			local TARGET = nil
			for E = 1, #TARGETVARIANTS do
				local PLAYER = TARGETVARIANTS[E]
				local CHARACTER_CANDIDATE = PLAYER[1]
				local DISTANCE = PLAYER[2]
				if DISTANCE < DIST then
					DIST = DISTANCE
					TARGET = CHARACTER_CANDIDATE
				end
			end
			if TARGET and TARGET:FindFirstChild("HumanoidRootPart") then
				local TARGETHUM = TARGET:FindFirstChildOfClass("Humanoid")
				if DIST <= 45 or TARGET:FindFirstChild("Polygoner_Trigger") then
					if TARGET:FindFirstChild("Polygoner_Trigger") == nil then
						local GONE = IT("Folder", TARGET)
						GONE.Name = "Polygoner_Trigger"
					end
					if MUSIC then MUSIC.Pitch = 0.5 end
					if HUMANOID and HUMANOID.WalkSpeed == 12 then
						for _, CHILD in pairs(ROOT:GetChildren()) do
							if CHILD:IsA("Sound") then
								CHILD:Stop()
							end
						end
						if ROOT:FindFirstChild("Kill") then ROOT.Kill:Play() end
					end
					if HUMANOID then
						HUMANOID.WalkSpeed = (TARGETHUM and TARGETHUM.WalkSpeed or 0) + 15
						if HUMANOID.WalkSpeed < 16 then HUMANOID.WalkSpeed = 16 end
					end
					if DIST <= 7 then
						if HUMANOID then HUMANOID.WalkSpeed = 0 end
						Execute(TARGET)
					end
				else
					if TARGETHUM and TARGETHUM.WalkSpeed > 16 then TARGETHUM.WalkSpeed = 16 end
					if MUSIC then MUSIC.Pitch = 0.35 end
					if HUMANOID then HUMANOID.WalkSpeed = 17 end
					if DIST <= 350 and MRANDOM(1, 125) == 1 then
						Chatter()
					end
				end
			else
				if MUSIC then MUSIC.Pitch = 0.35 end
			end
			wait()
		end
	end

	BEGINAI()
end
return gonerai

local NEVER_BREAK_JOINTS = false

local function CallOnChildren(Instance, FunctionToCall)
	FunctionToCall(Instance)
	for _, Child in next, Instance:GetChildren() do
		CallOnChildren(Child, FunctionToCall)
	end
end

local function GetNearestParent(Instance, ClassName)
	local Ancestor = Instance
	repeat
		Ancestor = Ancestor.Parent
		if Ancestor == nil then
			return nil
		end
	until Ancestor:IsA(ClassName)
	return Ancestor
end

local function GetBricks(StartInstance)
	local List = {}
	CallOnChildren(StartInstance, function(Item)
		if Item:IsA("BasePart") then
			List[#List + 1] = Item
		end
	end)
	return List
end

local function Modify(Instance, Values)
	assert(type(Values) == "table", "Values is not a table")
	for Index, Value in next, Values do
		if type(Index) == "number" then
			Value.Parent = Instance
		else
			Instance[Index] = Value
		end
	end
	return Instance
end

local function Make(ClassType, Properties)
	return Modify(Instance.new(ClassType), Properties)
end

local Surfaces = {"TopSurface", "BottomSurface", "LeftSurface", "RightSurface", "FrontSurface", "BackSurface"}
local HingSurfaces = {"Hinge", "Motor", "SteppingMotor"}

local function HasWheelJoint(Part)
	for _, SurfaceName in pairs(Surfaces) do
		for _, HingSurfaceName in pairs(HingSurfaces) do
			if Part[SurfaceName].Name == HingSurfaceName then
				return true
			end
		end
	end
	return false
end

local function ShouldBreakJoints(Part)
	if NEVER_BREAK_JOINTS then return false end
	if HasWheelJoint(Part) then return false end

	local Connected = Part:GetConnectedParts()
	if #Connected == 1 then return false end

	for _, Item in pairs(Connected) do
		if HasWheelJoint(Item) then
			return false
		elseif not Item:IsDescendantOf(Part.Parent) then
			return false
		end
	end
	return true
end

local function WeldTogether(Part0, Part1, JointType)
	JointType = JointType or "Weld"
	local RelativeValue = Part1:FindFirstChild("qRelativeCFrameWeldValue")

	local NewWeld = Part1:FindFirstChild("qCFrameWeldThingy") or Instance.new(JointType)
	Modify(NewWeld, {
		Name = "qCFrameWeldThingy",
		Part0 = Part0,
		Part1 = Part1,
		C0 = CFrame.new(),
		C1 = RelativeValue and RelativeValue.Value or Part1.CFrame:toObjectSpace(Part0.CFrame),
		Parent = Part1,
	})

	if not RelativeValue then
		Make("CFrameValue", {
			Parent = Part1,
			Name = "qRelativeCFrameWeldValue",
			Archivable = true,
			Value = NewWeld.C1,
		})
	end

	return NewWeld
end

local function WeldParts(Parts, MainPart, JointType, DoNotUnanchor)
	for _, Part in pairs(Parts) do
		if ShouldBreakJoints(Part) then
			Part:BreakJoints()
		end
	end

	for _, Part in pairs(Parts) do
		if Part ~= MainPart then
			WeldTogether(MainPart, Part, JointType)
		end
	end

	if not DoNotUnanchor then
		for _, Part in pairs(Parts) do
			Part.Anchored = false
		end
		MainPart.Anchored = false
	end
end

local function PerfectionWeld(ParentInstance)
	local Tool = GetNearestParent(ParentInstance, "Tool")

	local Parts = GetBricks(ParentInstance)
	local PrimaryPart = Tool and Tool:FindFirstChild("Handle") and Tool.Handle:IsA("BasePart") and Tool.Handle
		or ParentInstance:IsA("Model") and ParentInstance.PrimaryPart
		or Parts[1]

	if PrimaryPart then
		WeldParts(Parts, PrimaryPart, "Weld", false)
	end

	return Tool
end
for i,v in pairs(monster:GetDescendants()) do
if v.Name == "qPerfectionWeld" then
PerfectionWeld(v.Parent)
end
end
gonerai(monster)
