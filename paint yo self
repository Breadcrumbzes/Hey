local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

local tool

-- Locate tool
for _, v in pairs(player:GetDescendants()) do
	if v.Name == "SyncAPI" and v:FindFirstChild("ServerEndpoint") then
		tool = v.Parent
		break
	end
end

if not tool then
	for _, v in pairs(ReplicatedStorage:GetDescendants()) do
		if v.Name == "SyncAPI" and v:FindFirstChild("ServerEndpoint") then
			tool = v.Parent
			break
		end
	end
end

local remote = tool:WaitForChild("SyncAPI"):WaitForChild("ServerEndpoint")

-- ##################
-- REFACTORED HELPERS
-- ##################
local function CreatePart(cf, parent)
	return remote:InvokeServer("CreatePart", "Normal", cf, parent)
end

local function SafeInvoke(method, data)
	task.spawn(function()
		remote:InvokeServer(method, data)
	end)
end

local function Resize(part, size, cf)
	SafeInvoke("SyncResize", {{Part = part, CFrame = cf, Size = size}})
end

local function SetCollision(part, boolean)
	SafeInvoke("SyncCollision", {{Part = part, CanCollide = boolean}})
end

local function SetAnchor(part, boolean)
	SafeInvoke("SyncAnchor", {{Part = part, Anchored = boolean}})
end

local function SetColor(part, color)
	SafeInvoke("SyncColor", {{Part = part, Color = color, UnionColoring = false}})
end

local function SetTransparency(part, trans)
	SafeInvoke("SyncMaterial", {{Part = part, Transparency = trans}})
end

local function CreateDecal(part, face)
	SafeInvoke("CreateTextures", {{Part = part, Face = face, TextureType = "Decal"}})
end

local function ApplyDecalTexture(part, asset, face)
	SafeInvoke("SyncTexture", {{
		Part = part,
		Face = face,
		TextureType = "Decal",
		Texture = "rbxassetid://" .. asset
	}})
end

local function SetName(part, name)
	SafeInvoke("SetName", {part}, name)
end

local function CreateMesh(part)
	SafeInvoke("CreateMeshes", {{Part = part}})
end

local function SyncMeshId(part, id)
	SafeInvoke("SyncMesh", {{Part = part, MeshId = id}})
end

local function SyncMeshScale(part, scale)
	SafeInvoke("SyncMesh", {{Part = part, Scale = scale}})
end

-- #########################
-- IMPORT MODEL AND COPY IT
-- #########################

local obj = game:GetObjects("rbxassetid://72813564762155")[1]
obj.Parent = workspace
obj:PivotTo(char.HumanoidRootPart.CFrame * CFrame.new(0,0,-5))
wait(0.1)

for _, basepart in pairs(obj:GetDescendants()) do
	if basepart:IsA("BasePart") then
		task.spawn(function()
			-- create cloned synced part
			local newPart = CreatePart(basepart.CFrame, workspace)

			-- DECALS --------------------
			for _, decal in pairs(basepart:GetChildren()) do
				if decal:IsA("Decal") then
					-- create decal slot
					CreateDecal(newPart, decal.Face)

					-- apply texture
					if decal.Texture ~= "" then
						local assetId = string.gsub(decal.Texture, "%D", "")
						if assetId ~= "" then
							ApplyDecalTexture(newPart, assetId, decal.Face)
						end
					end
				end
			end

			-- properties sync -------------
			SetCollision(newPart, basepart.CanCollide)
			SetAnchor(newPart, basepart.Anchored)
			SetColor(newPart, basepart.Color)
			SetTransparency(newPart, basepart.Transparency)
			Resize(newPart, basepart.Size, basepart.CFrame)
			SetName(newPart, basepart.Name)

			-- MESHES -----------------------
			for _, mesh in pairs(basepart:GetChildren()) do
				if mesh:IsA("SpecialMesh") then
					CreateMesh(newPart)
					if mesh.MeshId ~= "" then
						local meshIdExtract = string.gsub(mesh.MeshId, "%D", "")
						if meshIdExtract ~= "" then
							SyncMeshId(newPart, meshIdExtract)
						end
					end
					-- scale
					SyncMeshScale(newPart, mesh.Scale)
				end
			end

			-- ##################################
			-- SPECIAL COLORBRICK SCANNER FEATURE
			-- ##################################

			if basepart.Name == "ColorBrick" then
			task.spawn(function()
	while newPart and newPart.Parent do
		task.wait(0.01)

		local touching = workspace:GetPartsInPart(newPart)

		-- if nil or empty, skip this loop iteration
		if not touching or #touching == 0 then
			continue
		end

		for _, hit in pairs(touching) do
			if hit:IsA("BasePart") and not hit.Anchored then
				SetColor(hit, newPart.Color)
			end
		end
	end
end)

			end

			basepart:Destroy()
		end)
	end
end

obj:Destroy()
